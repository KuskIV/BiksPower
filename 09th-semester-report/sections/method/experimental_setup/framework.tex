\subsection{Framework}\label[subsec]{subsec:framework}

In order to answer the first part of \textbf{RQ1}, a framework is introduced. This framework should be able to systematically measure the energy consumption of test cases on different DUTs and OSs. The measurements should be conducted in a rotated round-robin fashion using R3-Validation.\newline

The first thing to consider, is the measuring instruments and test cases, as both of these need to be implemented in a generic fashion, to be able to alter between them during runtime. Because of this, both are implemented using interfaces, as this was concluded not to impact performance for Java in the work by Sestoft\cite[]{sestoft2013microbenchmarks}, where it is assumed a similar conclusion would be made for C\#. When considering the measuring instrument, the implementation can be seen in \cref{lst:measurement_instruments}, where the \texttt{IMeasuringInstrument} has four methods implemented. The \texttt{Start} and \texttt{Stop}, start and stop the measuring instruments, where the input \texttt{date} in \texttt{Start} is used to name the file in which the results are saved. \texttt{GetName} is used to get the name of the current measuring instrument, also related to saving the data correctly. Lastly, \texttt{ParseCsv} is used to transform the data saved for a measuring instrument for one measurement, on a given time, into a \texttt{DtoRawData}, this being the format accepted by the database, which will be introduced in \cref{subsec:sql}.

\input{listings/i_measurement_instruments.tex}

Next up, the implementation for the test case can be seen in \cref{lst:test_case}, where the \texttt{ITestCase} implements four methods. Here the \texttt{GetLanguage} and \texttt{GetName} return the language the test case is implemented in, and the name of it respectively, which is used when saving the results. The \texttt{GetProgram} returns a \texttt{DtoTestCase} object containing data about the test case.  The \texttt{DtoTestCase} is saved in the database, and the last method \texttt{Run} executes the test case.

\input{listings/i_test_case.tex}

To get a better context of how the \texttt{IMeasuringInstrument} and \texttt{ITestCase} is used in the framework, pseudo code illustrating this can be seen in \cref{lst:execute_async}. \texttt{ExecuteAsync} will in line 5 wait until a stable condition is reached, where a stable condition is defined as a condition where the battery is charged to a certain level, and the CPU is below some temperature. Each time \texttt{ExecuteAsync} is executed, one test case will be used, as expressed in line 8. In lines 10-12 there are some conditionals regarding whether the framework should keep running the test case, or the DUT should restart. This will be decided based on three conditions, the first one being the method \texttt{ShouldStopMeasurement()}. This method will return \texttt{true} if the temperature is above some limit, or the battery levels are too low. \texttt{ismMasurementValid} ensures the last measurement was valid, and \texttt{EnoughEntires} ensures the method will not run forever, by restarting the DUT every time each measuring instrument has measured a test case a set number of times. On each iteration of the \texttt{While}-loop, a new measuring instrument is chosen, as can be seen in line 14, where \texttt{GetNextMeasuringInstrument} will take the next measuring instrument, based on which one was used in the last iteration. On the first iteration, the measuring instrument starting is based on which measuring instrument started last time the DUT was running, which is saved in the database, as covered in \cref{subsec:sql}. In line 18, the measurement is performed, and before and after this, different dependencies are initialized or removed. This includes for example a connection to the database, which is not required during the measurements. Lastly, in lines 25-26, the results are saved, and the DUT is restarted. 

\input{listings/execute_async.tex}

To get a better understanding of how the measurements are performed, pseudo-code for \texttt{RunMeasurement} from line 18 in \cref{lst:execute_async} can be seen in \cref{lst:run_experiments}. This method will count how many times the test case is executed during the given duration and handle measurements of temperatures and battery levels before and after the measurements in lines 4, 6, and 19 respectively. In line 7 the wifi/ethernet is disabled before the measurements are performed, line 9 triggers the garbage collection, to ensure all removed dependencies are cleaned up, and in line 11 the stopwatch and measuring instrument will be started. One thing to consider here is the order in which the measuring instrument and the stopwatch are started, since if the stopwatch is started first, it will also measure the time it took for the measuring instrument to start and stop, and if the measuring instrument is started first, the energy consumption of starting and stopping the stopwatch will be included. In this work, the stopwatch will be started first, as this was the setup in the work by Pereira et al.\cite[]{Pereira2017}, where both versions of either starting the stopwatch or measuring instrument first were tested, and the impact was concluded to be insignificant. In addition to this, the impact will become even small if the test case executes multiple times between the start and stop of the measuring instrument. In line 13, the \texttt{ITestCase} will execute, until some predefined number of minutes has passed. When the measurement is done, the wifi/ethernet will be enabled again in line 22, and the result will be handled.

\input{listings/run_experiments.tex}



