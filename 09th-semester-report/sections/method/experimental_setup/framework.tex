\subsection{Framework}\label[subsec]{subsec:framework}

In order to answer the first part of \textbf{RQ1}, a framework is introduced. This framework should be able to systematically measure the energy consumption of a test case on different DUTs and OSs. The measurements should be conducted in a rotated round-robin fashion using R3-Validation.\newline

The first thing to consider, is the measuring instruments and test cases, as both of these need to be implemented in a generic fashion, to be able to alter between them during runtime. Because of this, both are implemented using interfaces, as this was concluded not to impact the performance of the system for Java in the work by Sestoft\cite[]{sestoft2013microbenchmarks}, where it is assumed a similar conclusion would be made for C\#. When considering the measuring instrument, the implementation can be seen in \cref{lst:measurement_instruments}, where the \texttt{IMeasuringInstrument} has four methods implemented. The \texttt{Start} and \texttt{Stop}, starts and stops the measuring instruments, where the input \texttt{date} in \texttt{Start} is used to name the file in which the data is saved. \texttt{GetName} is used to get the name of the current measuring instrument, also related to saving the data correctly. Lastly, \texttt{ParseCsv} is used to transform the data saved for a measuring instrument during an experiment, on a given time, into a \texttt{DtoRawData}, this being the format accepted by the database, which will be introduced in \cref{subsec:sql}.

\input{listings/i_measurement_instruments.tex}

Next up, the implementation for the test case can be seen in \cref{lst:test_case}, where the \texttt{ITestCase} implements four methods. Here the \texttt{GetLanguage} and \texttt{GetName} return the language the test case is implemented in, and the name of it respectively, which is used when saving the results. The \texttt{GetProgram} returns the \texttt{DtoTestCase}, which is used to upload results to the database, and \texttt{Run} executes the test case..

\input{listings/i_test_case.tex}

To get a better context of how the \texttt{IMeasuringInstrument} and \texttt{ITestCase} is used in the framework, pseudo code illustrating this can be seen in \cref{lst:execute_async}. \texttt{ExecuteAsync} will in line 5 wait until a stable condition is reached, which will wait until a certain temperature and battery level is reached, before proceeding. Each time \texttt{ExecuteAsync} is executed, it will be done with the test case from line 8. In lines 10-12 it can be observed when the DUT will restart, which will be decided based on three conditions. This is first of all the temperature and battery level of the system in \texttt{ShouldStopExperiment}, \texttt{isExperimentValid} ensures the last experiment was valid, and \texttt{EnoughEntires} ensures the experiment will not run forever, by restarting the DUT every time each measuring instrument has measured a test case a set number of times. On each iteration of the \texttt{While}-loop, a new measuring instrument is chosen, as can be seen in line 14, where \texttt{GetNextMeasuringInstrument} will take the next one, based on which one was used in the last iteration. On the first iteration, the measuring instrument starting is based on which measuring instrument started last time the DUT was running, which is saved in the database, as covered in \cref{subsec:sql}. In line 18, the experiment is run, and before and after this, different dependencies are initialized or removed. This includes for example a connection to the database, which is not required during the experiments. Lastly, in lines 25-26, the results are saved, and the computer is restarted. 

\input{listings/execute_async.tex}

To get a better understanding of how the experiments are run, pseudo-code for \texttt{RunExperiment} from line 18 in \cref{lst:execute_async} can be seen in \cref{lst:run_experiments}. This method will count how many times the test case is executed during the the given duration and handle measurements of temperatures and battery levels before and after the experiments in lines 4, 6 and 19 respectively. In line 7 the wifi/ethernet is disabled before the experiments are conducted, line 8 triggers the garbage collection, to ensure all removed dependencies are cleaned up and in line 11 the stopwatch and measuring instrument will be started. One thing to consider here is the order in which the measuring instrument and the stopwatch are started, since if the stopwatch is started first, it will also measure the time it took for the measuring instrument to start and stop, and if the measuring instrument is started first, the energy consumption of starting and stopping the stopwatch will be included. In this work, the stopwatch will be started first, as this was the setup in the work by Pereira et al.\cite[]{Pereira2017}, where both versions were tested, and the impact was concluded to be insignificant. In addition to this, the impact will become even small if the test case executes multiple times between the start and stop of the measuring instrument. In lines 13, the \texttt{ITestCase} will execute, until some predefined number of minutes has passed. When the experiment is done, the wifi/ethernet will be enabled again in line 21, and the result will be handled.

\input{listings/run_experiments.tex}



