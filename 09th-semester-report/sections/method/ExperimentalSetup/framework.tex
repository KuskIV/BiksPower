\subsection{Framework}

To conduct the experiments a framework is needed. This framework must be able to run test cases and measure the energy consumption using the different measuring instruments in a rotated round-robin fashion using R3-Validation. In addition to this, different procedures were presented in \cref{subsec:how_to_measure}, which are considered when creating the framework.

The first thing to consider, is the measuring instruments and test cases, as both of these need to be implemented generically, to be able to alter between them during runtime. Because of this, both are implemented using interfaces, as this was concluded not to impact the performance of the system for Java in the work by Sestoft\cite[]{sestoft2013microbenchmarks}, where it is assumed a similar conclusion would be made for C\#. When considering the measuring instrument, the implementation can be seen in \cref{lst:measurement_instruments}, where the \texttt{IMeasuringInstrument} has four methods implemented. The \texttt{Start} and \texttt{Stop}, start and stop the measuring instruments, where the input \texttt{date} in \texttt{Start} is used to name the file in which the data is saved. \texttt{GetName} is used to get the name of the current measuring instrument, used for logging and specifying which folder the data will be saved in. Lastly, \texttt{ParseCsv} is used to transform the data saved for a measurement instrument during an experiment, on a given time, into a \texttt{DtoRawData}, this being the format accepted by the database.

\input{listings/i_measurement_instruments.tex}

Next up, the implementation for the test case can be seen in \cref*{lst:test_case}, where the \texttt{ITestCase} implements four methods. Here the \texttt{GetLanguage} and \texttt{GetName} return the language the test case is implemented in, and the name of it respectively. The \texttt{GetProgram} returns the \texttt{DtoTestCase}, which is used to upload to the database, and \texttt{Run} executes the test case one time and then returns.

\input{listings/i_test_case.tex}

To get a better context of how the \texttt{IMeasuringInstrument} and \texttt{ITestCase} is used in the framework, some pseudo code representing the outer method handling dependencies and the validity of the result can be seen in \cref*{lst:execute_async}. \texttt{ExecuteAsync} will in line 5 wait until a stable condition is reached, which will be based on the temperature and the battery level, before proceeding. Each time \texttt{ExecuteAsync} is run, it will be done on the same test case, as can be seen in line 8. In lines 10-12 it can be observed when the DUT will restart, which will be decided based on three methods. This is first of all the temperature and battery level of the system in \texttt{ShouldStopExperiment}, \texttt{isExperimentValid} ensures the last experiment was valid, and \texttt{EnoughEntires} ensures the experiment will not run forever, by restarting the DUT every time the batch has executed for each measurement instrument. On each iteration of the \texttt{While}-loop, a new measuring instrument is chosen, as can be seen in line 14, where \texttt{GetNextMeasuringInstrument} will take the next one, based on which one was used in the last iteration. On the first iteration, the measuring instrument starting is based on which measuring instrument started in the last batch with the same configuration, which is saved in the database, as covered in \cref{subsec:sql}. In line 18, the experiment is run, and before and after this, different dependencies are initialized or removed. This includes for example a connection to the database, which is not required during the experiments. Lastly, in lines 25-26, the results are saved, and the computer is restarted. 

\input{listings/execute_async.tex}

To get a better understanding of how the experiments are run, pseudo-code for \texttt{RunExperiment} from line 18 in \cref{lst:execute_async} can be seen in \cref{lst:run_experiments}. This method will count how many times the test case is executed and handle measurements of temperatures and battery levels before and after the experiments in lines 4, 6 and 23 respectively. In line 7 the wifi/ethernet is disabled before the experiments are conducted, line 8 triggers the garbage collection, to ensure all removed dependencies are cleaned up and in line 11 the stopwatch and measuring instrument will be started. One thing to consider here is the order in which the measurement instrument and the stopwatch are started, since if the stopwatch is started first, it will also measure the time it took for the measuring instrument to start and stop, and if the measuring instrument is started first, the energy consumption of starting and stopping the stopwatch will be included. In this work, the stopwatch will be started first, as this was the setup in the work by Pereira et al.\cite*[]{Pereira2017}, where both versions were tested, and the impact was concluded to be insignificant. In addition to this, the impact will become even small if the test case executes multiple times between the start and stop of the measuring instrument. In lines 13-17, the \texttt{ITestCase} will execute, until some predefined number of minutes has passed. When the experiment is done, the wifi/ethernet will be enabled again in line 21, and the result will be handled.

\input{listings/run_experiments.tex}



